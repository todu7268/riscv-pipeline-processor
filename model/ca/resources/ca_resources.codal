/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of
 * Codasip s.r.o. and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip s.r.o. and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 *  \file   ca_
 *  """""""""""""""""""""""""""""resources.codal
 *  \author Codasip
 *  \date   09.02.2022
 *  \brief  cycle accurate model
 */

#include "ca_defines.hcodal"
#include "config.hcodal"

#define BOOLEAN_BIT     1    // Boolean control bit of width 1-bit
#define TWO_BIT         2       // Two bit wide control signal

pipeline pipe
{
    IFID, IDEX, EXMEM, MEMWB
};

// -------------------------------------------------------------------------------------------------
// Fetch stage
// -------------------------------------------------------------------------------------------------
// Current Program Counter (PC) address of instruction fetch request
signal bit[ADDR_W]                  s_if_nextpc;

// IFID pipeline register
register bit[ADDR_W]                r_ifid_pc                    { pipeline = pipe.IFID; }; // Program Counter

// -------------------------------------------------------------------------------------------------
// Decode stage
// -------------------------------------------------------------------------------------------------
// Instruction and parsed instruction fields
signal bit[INSTR_W]                 s_id_instr;                                             // Instruction
signal bit[OPC_W]                   s_id_opcode;                                            // Complete 17-bit opcode
signal bit[RF_XPR_W]                s_id_src1;                                              // src1 register address
signal bit[RF_XPR_W]                s_id_src2;                                              // src2 register address
signal bit[RF_XPR_W]                s_id_rd;                                                // rd destination address
signal bit[WORD_W]                  s_id_rf_src1;                                           // value of src1 from register file
signal bit[WORD_W]                  s_id_rf_src2;                                           // value of src2 from regsiter file

// ALU Operation Control
signal bit[ALUOP_W]                 s_id_aluop;                                             // ALU opcode
signal bit[BOOLEAN_BIT]             s_id_halt;                                              // Control bit to halt processor simulation

// Immediate operand generation resources
signal bit[IMM_GEN_SEL_W]           s_id_imm_gen_sel;                                       // select the type of immediate to pass to execute stage
signal bit[WORD_W]                  s_id_imm_rtype;
signal bit[WORD_W]                  s_id_imm_itype;
signal bit[WORD_W]                  s_id_imm_stype;
signal bit[WORD_W]                  s_id_imm_btype;
signal bit[WORD_W]                  s_id_imm_utype;
signal bit[WORD_W]                  s_id_imm_jtype;
signal bit[WORD_W]                  s_id_src2_imm;

// Singals/registers to preserve instruction durin a pipeline stall
signal bit[BOOLEAN_BIT]             s_id_icache_stall;
register bit[BOOLEAN_BIT]           r_id_icache_stall            {default = false;};        // 1-cycle delay of s_id_icache_stall for timing
register bit[BOOLEAN_BIT]           r_id_flush_icache            {default = false;};        // used to flush current instruction being read
register bit[BOOLEAN_BIT]           r_id_buffer_full             {default = false;};        // indicate whether previous cycle stalled
register bit[INSTR_W]               r_id_instr_preserved;                                   // Preserve last instruction to reconstruct inst. in stall
register bit[WORD_W]                r_id_pc_preserved;                                      // Preserve the PC address of instruction safed in buffer

// Signals generated by the Instruction Decoder
signal bit[BOOLEAN_BIT]             s_id_regwrite;                                          // Write to rd (write register) if true
signal bit[ALU_SRC1_SEL_W]          s_id_alusrc1;                                           // src1 operand mux select line
signal bit[ALU_SRC2_SEL_W]          s_id_alusrc2;                                           // src2 operand mux select line
signal bit[MEM_OPCODE_W]            s_id_mem_ops;                                           // Memory opcode
signal bit[BOOLEAN_BIT]             s_id_memread;                                           // Memory load operation if true
signal bit[BOOLEAN_BIT]             s_id_branch_inst;                                       // bit used to notify an instruction is a branch
signal bit[BOOLEAN_BIT]             s_id_jump_inst;                                         // bit used to notify a jump instruction

// IDEX pipeline register
        { pipeline = pipe.IDEX; };  // Program Counter
        { pipeline = pipe.IDEX; };  // rd (write) register number
        { pipeline = pipe.IDEX; };  // register file output for src1
        { pipeline = pipe.IDEX; };  // register file output for src2
        { pipeline = pipe.IDEX; };  // RF write? r_idex_regwrite
        { pipeline = pipe.IDEX; };  // immediate value for src2

register bit[ALUOP_W]               r_idex_aluop                { pipeline = pipe.IDEX; };  // ALU opcode
register bit[ALU_SRC1_SEL_W]        r_idex_src1_sl              { pipeline = pipe.IDEX; };  // ALU src1 select lines for mux
register bit[ALU_SRC2_SEL_W]        r_idex_src2_sl              { pipeline = pipe.IDEX; };  // ALU src2 select lines for mux
register bit[BOOLEAN_BIT]           r_idex_branch_inst          { pipeline = pipe.IDEX; };  // If true, conditional branch instruction
register bit[BOOLEAN_BIT]           r_idex_jump_inst            { pipeline = pipe.IDEX; };  // If true, jump instruction
register bit[MEM_OPCODE_W]          r_idex_mem_ops              { pipeline = pipe.IDEX; };  // Opcode for Loads and Store operations (NOP = no load or store)
register bit[BOOLEAN_BIT]           r_idex_memread              { pipeline = pipe.IDEX; };  // If true, it is a Load operation
register bit[BOOLEAN_BIT]           r_idex_halt                 { pipeline = pipe.IDEX; };  // Halt control bit

// -------------------------------------------------------------------------------------------------
// Execute stage
// -------------------------------------------------------------------------------------------------
// ALU signals
        // src1 operand into ALU
        // src2 operand into ALU
        // result of ALU operation

// EXMEM pipeline register
        // Data result from ALU
register bit[RF_XPR_W]              r_exmem_rd                 { pipeline = pipe.EXMEM; };  // rd / write register
register bit[BOOLEAN_BIT]           r_exmem_regwrite           { pipeline = pipe.EXMEM; };  // Does the current instruction wrt to RF
register bit[BOOLEAN_BIT]           r_exmem_branch_inst        { pipeline = pipe.EXMEM; };  // If true, conditional branch instruction
register bit[BOOLEAN_BIT]           r_exmem_jump_inst          { pipeline = pipe.EXMEM; };  // If true, jump instruction
register bit[MEM_OPCODE_W]          r_exmem_mem_ops            { pipeline = pipe.EXMEM; };  // Opcode for Loads and Store operations (NOP = no load or store)
register bit[BOOLEAN_BIT]           r_exmem_memread            { pipeline = pipe.EXMEM; };  // If true, it is a Load operation
register bit[ADDR_W]                r_exmem_target_address     { pipeline = pipe.EXMEM; };  // Address to branch or jump to if required

// -------------------------------------------------------------------------------------------------
// Memory stage
// -------------------------------------------------------------------------------------------------
signal bit[BOOLEAN_BIT]             s_me_take_branch;                                       //Informs the pipeline in a branch or jump is occuring
signal bit[BOOLEAN_BIT]             s_me_mem_busy;                                          // Memory bus is busy

// MEMWB pipeline register
        // ALU result from Memory stage
        // Destination, rd, register index
        // Register Write (regwrite)

// -------------------------------------------------------------------------------------------------
// Writeback stage
// -------------------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------------------
// Pipeline control
// -------------------------------------------------------------------------------------------------
signal   bit[BOOLEAN_BIT]           s_id_stall;
signal   bit[BOOLEAN_BIT]           s_wb_stall;

// -------------------------------------------------------------------------------------------------
// SYSCALL support for simulation
// -------------------------------------------------------------------------------------------------
signal bit [BOOLEAN_BIT]            s_syscall_pending;
signal bit [BOOLEAN_BIT]            s_syscall_stall;
register bit [TWO_BIT]              r_syscall_delay         {default = 0;};

